## API Report File for "astro-context"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import ContextProvider from './ContextProvider.astro';

// @public
export class Context<T, _Info extends [`storage:${StorageVariants}`]> {
    constructor(name: string, initialValue: _GetInitialValueFn<T> | T, config?: Partial<ContextConfig<T, any>>);
    // @internal
    config: ContextConfig<T, StorageVariants>;
    get<S extends string | undefined = undefined>(scope?: S): S extends undefined ? T : T | undefined;
    // @internal
    getInitialValue: _GetInitialValueFn<T>;
    readonly name: string;
    providerTraits(store?: Store): {
        'data-context-id': string;
        'data-context-scope': string;
        'data-context-stable': boolean | undefined;
    };
    set(value: T, scope?: Context.inferStorage<Context<any, _Info>> extends 'memory' ? string : 'global'): void;
    // @internal
    storage: _StorageService;
}

// @public
export namespace Context {
    export type inferInfo<C extends Context<any, any>> = C extends Context<any, infer Info> ? Info : never;
    export type inferStorage<C extends Context<any, any>> = C extends Context<any, infer Storage> ? Storage extends [`storage:${infer S}`] ? S : never : never;
}

// @public
export class ContextConfig<T, Storage extends StorageVariants = 'memory'> {
    constructor(storage?: Storage, stringify?: (value: T) => string);
    readonly storage: Storage;
    readonly stringify: (value: T) => string;
}

// @public
export namespace ContextConfig {
    export type inferStorage<C extends ContextConfig<any, any>> = C extends ContextConfig<infer Storage> ? Storage : inferStorage<ContextConfig<any>>;
}

export { ContextProvider }

// @public
export const createContext: CreateContextFn;

// @public
export interface CreateContextFn {
    <T, S extends StorageVariants = ContextConfig.inferStorage<ContextConfig<any>>>(name: string, initialValue: ((persistedValue?: S extends 'localStorage' ? string | undefined : undefined) => T) | T, config?: Partial<ContextConfig<T, S>>): Context<T, [`storage:${S}`]>;
}

// @public
export const createStore: (name: string) => Store;

// @public
export const getDefaultStore: () => Store;

// @public
export type _GetInitialValueFn<T> = (persistedValue?: string) => T;

// @public
export class ScopedContext<T> {
    constructor(context: Context<T, any>, store: Store);
    listen: (callback: (value: T) => void) => () => void;
    subscribe: (callback: (value: T) => void) => () => void;
    get value(): T;
    set value(value: T);
}

// @internal
export interface _Storage {
    get<T>(name: Context<T, any>, scope: string): T;
    set<T>(name: Context<T, any>, scope: string, value: T): void;
}

// @internal
export class _StorageService implements _Storage {
    constructor(storage: StorageVariants);
    get: _Storage['get'];
    set: _Storage['set'];
}

// @public
export type StorageVariants = 'memory' | 'localStorage';

// @public
export class Store {
    constructor(scope?: string, scopeName?: string);
    get<T>(context: Context<T, any>): T;
    listen<T>(context: Context<T, any>, callback: (value: T) => void): () => void;
    readonly scope: string;
    readonly scopeName: string | undefined;
    set<T>(context: Context<T, any>, value: T): void;
    subscribe<T>(context: Context<T, any>, callback: (value: T) => void): () => void;
}

// @public
export const useContext: <T>(context: Context<T, any>, node?: HTMLElement) => ScopedContext<T>;

```
